---
---

## Variables

Variable assignment attaches the label left of an `=` to the return value of the expression on its right.

```{python, term = False}
a = 'xyz'
```

Colloquially, you might say the new variable `a` equals `'xyz'`, but Python makes it easy to "go deeper". Because there can be only one string `'xyz'`, the Python interpreter makes `a` into another label for the same `'xyz'`, which we can verify by `id()`.

===

The "in-memory" location of `a` returned by `id()` ...

```{python}
id(a)
```

... is equal to that of `xyz` itself:

```{python}
id('xyz')
```

The idiom to test this "sameness" is typical of the Python language: it uses plain English when words will suffice.

```{python}
a is 'xyz'
```

===

## Equal but not the Same

The `id()` function helps demonstrate that "equal" is not the "same".

```{python}
b = [1, 2, 3]
id(b)
```

The "in-memory" location of the list labeled `b` isn't the same as a list generated on-the-fly:

```{python}
id([1, 2, 3])
```

Even though `b == [1, 2, 3]` returns `True`, these are not the same object:

```{python}
b is [1, 2, 3]
```

===

## Side-effects

The reason to be aware of what `b` **is** has to do with "side-effects", an import part of Python programming. A side-effect occurs when an expression generates some ripples other than its return value. And side-effects don't change the label, they effect what the label is assigned to (i.e. what it **is**).

```{python}
b.pop()
```

```{python}
b
```

===

Question
: Re-check the "in-memory" location---is it the same `b`?

Answer
: Yes! The list got shorter but it is the same list.
{:.fragment}

===

Where side-effects trip up Python programmers is when an object has multiple labels. It's not so unusual:

```{python}
c = b
b.pop()
c
```

The assignment to `c` does not create a new list, so the side-effect of popping off the tail of `b` ripples into `c`.

A common mistake for those coming to Python from R, is to write `b = b.append(4)`, which overwrites `b` with the value `None` that happens to be returned by the `list.append()` function.
{:.notes}

===

Not every object is mutable; for example, the `a` assigned earlier is not.

```{python}
x = a
a.upper()
```

```{python}
x
```

The string 'xyz' hasn't changed---it's immutable. So it is also a safe guess that there has been no side-effect:

```{python}
a
```
